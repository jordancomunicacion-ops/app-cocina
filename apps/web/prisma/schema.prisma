// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 1. Users & Roles
model User {
  id       String @id @default(cuid())
  name     String
  email    String @unique
  password String
  role     String @default("EMPLOYEE") // ADMIN, CHEF, EMPLOYEE

  // Extended Profile Fields (Matches App Ganadera)
  firstName String?
  lastName  String?
  dni       String?
  phone     String?
  jobTitle  String?
  dob       DateTime?
  image     String? // URL to profile image

  tasks     Task[]     @relation("AssignedTasks")
  auditLogs AuditLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 7. App Configuration
model AppConfig {
  id      String  @id @default("default")
  logoUrl String? // URL to app logo

  updatedAt DateTime @updatedAt
}

model RecipeCategory {
  id    String @id @default(cuid())
  name  String @unique
  
  order Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RecipePackaging {
  id    String @id @default(cuid())
  name  String @unique
  
  order Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 2. Ingredients (Productos)
model Ingredient {
  id            String  @id @default(cuid())
  name          String
  category      String?
  pricingUnit   String  @default("KG") // KG, G, L, ML, UD
  pricePerUnit  Float // e.g., 10.50 (Euros)
  yieldPercent  Float   @default(100.0) // 100% means no loss. 80% means 20% loss.
  allergens     String? // SQLite does not support JSON well in standard prisma, usually String or serialized. Wait, Prisma supports JSON in SQLite?
  // "The Json type is supported...". Let's verify.
  allergensJson String? // Store as JSON string explicitly to be safe or use Bytes. 
  // Actually Prisma supports generic Json on SQLite since v3. I will try keeping Json type IF validation allows it.
  // If validation fails for JSON, I will switch to String.
  // Docs say: "SQLite doesn't support JSON type natively but Prisma polyfills it".
  // allergens       Json? // Retrying Json? The validation error before was about ENUMS.

  supplierId String?

  purchaseFormats PurchaseFormat[]
  recipeItems     RecipeItem[]
  recipeSteps     RecipeStep[]

  // New Relation: Ingredient comes from a Transformation Output
  transformationOutputs TransformationOutput[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// -----------------------------------------------------------------------------
// NEW: PRODUCT & TRANSFORMATION ARCHITECTURE
// -----------------------------------------------------------------------------

// Lo que compras (SupplierProduct)
model SupplierProduct {
  id       String  @id @default(cuid())
  name     String // "Solomillo Vaca Rubia - Prov A"
  supplier String?
  price    Float // Price per unit (e.g. 18.00)
  unit     String // KG, BOX, PACK
  sapiensWorld String? // Reino Animal, Reino Vegetal, Reino Fungi, Mundo Mineral

  transformations Transformation[]

  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  RecipeItem RecipeItem[]
}

// La regla de conversi√≥n (Transformation/Despiece)
model Transformation {
  id   String @id @default(cuid())
  name String // "Limpieza Standard"

  // Input (Source)
  sourceProduct   SupplierProduct @relation(fields: [sourceProductId], references: [id])
  sourceProductId String

  // Outputs (Destinations)
  outputs TransformationOutput[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model TransformationOutput {
  id String @id @default(cuid())

  transformation   Transformation @relation(fields: [transformationId], references: [id], onDelete: Cascade)
  transformationId String

  // Link to the Ingredient that is generated
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id])
  ingredientId String // Removed @unique to allow multiple transformations to produce the same ingredient

  percentage     Float // e.g. 60.0 (60%) yield of the source weight
  costAllocation Float // e.g. 1.2 (Allocates 1.2x cost per kg relative to source avg)
}

// -----------------------------------------------------------------------------

// Formatos de compra (e.g. "Saco 25kg")
model PurchaseFormat {
  id                String @id @default(cuid())
  name              String
  quantityPerFormat Float // e.g. 25
  formatUnit        String // e.g. KG
  price             Float // Price for the whole format (e.g. 25 EUR)

  ingredient   Ingredient @relation(fields: [ingredientId], references: [id])
  ingredientId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 3. Recipes (Elaboraciones)
model Recipe {
  id            String  @id @default(cuid())
  name          String
  version       Int     @default(1)
  yieldQuantity Float // e.g. 10 (Servings) or 2 (KG)
  yieldUnit     String? // Optional unit
  instructions  String?
  isSubRecipe   Boolean @default(false)

  category        String        @default("ELABORACION_FINAL") // PRODUCTO_NO_ELABORADO, ELABORACION_INTERMEDIA, ELABORACION_FINAL
  classification  String?       // Old "Category" (e.g. Postres, Salsas)
  packaging String?
  portions  Int?
  prepTime  Int? // Minutes
  cookTime  Int? // Minutes

  steps RecipeStep[]

  items RecipeItem[] @relation("RecipeToItems")

  // Inverse relation: This recipe can be used as an item in other recipes (if it's a sub-recipe)
  usedInRecipes RecipeItem[] @relation("SubRecipeRef")

  // For Events
  menuItems EventMenuItem[]

  // For Tasks (Production tasks)
  tasks Task[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RecipeStep {
  id String @id @default(cuid())

  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId String

  order       Int
  description String

  // Structured Data
  action    String? // CORTAR, DESPIEZAR, COCCION
  subAction String? // BRUNOISSE, FILETEAR, AL_VACIO

  ingredient   Ingredient? @relation(fields: [ingredientId], references: [id])
  ingredientId String?
}

// Lines in a recipe (Ingredients or other Recipes)
model RecipeItem {
  id String @id @default(cuid())

  recipe   Recipe @relation("RecipeToItems", fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId String

  type String // INGREDIENT, SUB_RECIPE

  // Link to Ingredient
  ingredient   Ingredient? @relation(fields: [ingredientId], references: [id])
  ingredientId String?

  // Link to Recipe (Sub-recipe)
  subRecipe   Recipe? @relation("SubRecipeRef", fields: [subRecipeId], references: [id])
  subRecipeId String?

  quantityGross Float // Quantity needed before cleaning/prep
  quantityNet   Float? // Optional: Net quantity actually used
  unit          String

  // Link to a specific Supplier Product (Optional: to enforce a specific brand/provider)
  sourceProduct   SupplierProduct? @relation(fields: [sourceProductId], references: [id])
  sourceProductId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 4. Events
model Event {
  id           String   @id @default(cuid())
  name         String
  date         DateTime
  pax          Int // Number of guests
  safetyMargin Float    @default(1.1) // 1.1 = +10%
  status       String   @default("DRAFT") // DRAFT, CONFIRMED, COMPLETED

  menuItems EventMenuItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EventMenuItem {
  id      String @id @default(cuid())
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId String

  recipe   Recipe @relation(fields: [recipeId], references: [id])
  recipeId String

  servingsOverride Int? // If different from Event PAX
}

// 5. Tasks
model Task {
  id          String  @id @default(cuid())
  title       String
  description String?

  assignedTo       User?   @relation("AssignedTasks", fields: [assignedToUserId], references: [id])
  assignedToUserId String?

  status String @default("PENDING") // PENDING, IN_PROGRESS, DONE, ISSUE

  plannedStart DateTime?
  plannedEnd   DateTime?
  realStart    DateTime?
  realEnd      DateTime?

  // Linking a task to a recipe production
  recipe         Recipe? @relation(fields: [recipeId], references: [id])
  recipeId       String?
  targetQuantity Float? // How much to produce

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 6. Audit & Logs
model AuditLog {
  id        String @id @default(cuid())
  tableName String
  recordId  String
  action    String // CREATE, UPDATE, DELETE

  changedBy       User?   @relation(fields: [changedByUserId], references: [id])
  changedByUserId String?

  timestamp DateTime @default(now())
  changes   String? // Changed from Json to String to handle SQLite json safely (though Json type might work)
  // Let's use String for simple robustness on downgrade.
}
