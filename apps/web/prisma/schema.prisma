// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 1. Users & Roles
model User {
  id              String    @id @default(cuid())
  name            String
  email           String    @unique
  password        String
  role            String    @default("EMPLOYEE") // ADMIN, CHEF, EMPLOYEE
  
  // Extended Profile Fields (Matches App Ganadera)
  firstName       String?
  lastName        String?
  dni             String?
  phone           String?
  jobTitle        String?
  dob             DateTime?
  
  tasks           Task[]    @relation("AssignedTasks")
  auditLogs       AuditLog[]

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

// 2. Ingredients (Productos)
model Ingredient {
  id              String           @id @default(cuid())
  name            String
  category        String?
  pricingUnit     String           @default("KG") // KG, G, L, ML, UD
  pricePerUnit    Float            // e.g., 10.50 (Euros)
  yieldPercent    Float            @default(100.0) // 100% means no loss. 80% means 20% loss.
  allergens       String?          // SQLite does not support JSON well in standard prisma, usually String or serialized. Wait, Prisma supports JSON in SQLite?
                                   // "The Json type is supported...". Let's verify.
  allergensJson   String?          // Store as JSON string explicitly to be safe or use Bytes. 
                                   // Actually Prisma supports generic Json on SQLite since v3. I will try keeping Json type IF validation allows it.
                                   // If validation fails for JSON, I will switch to String.
                                   // Docs say: "SQLite doesn't support JSON type natively but Prisma polyfills it".
  // allergens       Json? // Retrying Json? The validation error before was about ENUMS.
  
  supplierId      String?

  purchaseFormats PurchaseFormat[]
  recipeItems     RecipeItem[]
  
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
}

// Formatos de compra (e.g. "Saco 25kg")
model PurchaseFormat {
  id                String      @id @default(cuid())
  name              String
  quantityPerFormat Float       // e.g. 25
  formatUnit        String      // e.g. KG
  price             Float       // Price for the whole format (e.g. 25 EUR)
  
  ingredient        Ingredient  @relation(fields: [ingredientId], references: [id])
  ingredientId      String

  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
}

// 3. Recipes (Elaboraciones)
model Recipe {
  id              String        @id @default(cuid())
  name            String
  version         Int           @default(1)
  yieldQuantity   Float         // e.g. 10 (Servings) or 2 (KG)
  yieldUnit       String?       // Optional unit
  instructions    String?
  isSubRecipe     Boolean       @default(false)
  
  items           RecipeItem[]  @relation("RecipeToItems")
  
  // Inverse relation: This recipe can be used as an item in other recipes (if it's a sub-recipe)
  usedInRecipes   RecipeItem[]  @relation("SubRecipeRef")

  // For Events
  menuItems       EventMenuItem[]
  
  // For Tasks (Production tasks)
  tasks           Task[]

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Lines in a recipe (Ingredients or other Recipes)
model RecipeItem {
  id              String      @id @default(cuid())
  
  recipe          Recipe      @relation("RecipeToItems", fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId        String

  type            String      // INGREDIENT, SUB_RECIPE
  
  // Link to Ingredient
  ingredient      Ingredient? @relation(fields: [ingredientId], references: [id])
  ingredientId    String?

  // Link to Recipe (Sub-recipe)
  subRecipe       Recipe?     @relation("SubRecipeRef", fields: [subRecipeId], references: [id])
  subRecipeId     String?

  quantityGross   Float       // Quantity needed before cleaning/prep
  quantityNet     Float?      // Optional: Net quantity actually used
  unit            String

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
}

// 4. Events
model Event {
  id            String          @id @default(cuid())
  name          String
  date          DateTime
  pax           Int             // Number of guests
  safetyMargin  Float           @default(1.1) // 1.1 = +10%
  status        String          @default("DRAFT") // DRAFT, CONFIRMED, COMPLETED

  menuItems     EventMenuItem[]

  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
}

model EventMenuItem {
  id              String    @id @default(cuid())
  event           Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId         String

  recipe          Recipe    @relation(fields: [recipeId], references: [id])
  recipeId        String

  servingsOverride Int?     // If different from Event PAX
}

// 5. Tasks
model Task {
  id              String      @id @default(cuid())
  title           String
  description     String?
  
  assignedTo      User?       @relation("AssignedTasks", fields: [assignedToUserId], references: [id])
  assignedToUserId String?

  status          String      @default("PENDING") // PENDING, IN_PROGRESS, DONE, ISSUE

  plannedStart    DateTime?
  plannedEnd      DateTime?
  realStart       DateTime?
  realEnd         DateTime?

  // Linking a task to a recipe production
  recipe          Recipe?     @relation(fields: [recipeId], references: [id])
  recipeId        String?
  targetQuantity  Float?      // How much to produce

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
}

// 6. Audit & Logs
model AuditLog {
  id              String      @id @default(cuid())
  tableName       String
  recordId        String
  action          String      // CREATE, UPDATE, DELETE
  
  changedBy       User?       @relation(fields: [changedByUserId], references: [id])
  changedByUserId String?

  timestamp       DateTime    @default(now())
  changes         String?     // Changed from Json to String to handle SQLite json safely (though Json type might work)
                              // Let's use String for simple robustness on downgrade.
}
